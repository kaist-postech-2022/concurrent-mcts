pub mod mcts;

use std::{
    fmt,
    hash::Hash,
    marker::PhantomData,
    sync::atomic::{AtomicU64, Ordering},
};

use atomic_float::AtomicF64;
use dashmap::DashMap;
use serde::{Deserialize, Serialize};

pub trait Action: Clone + Send + Sync {
    fn choose_weight(&self) -> f64 {
        1.
    }
}

pub trait Player: Clone + Send + Sync {
    fn id(&self) -> usize;
}

pub trait State<P: Player, A: Action>: Clone + Hash + PartialEq + Eq + Send + Sync {
    fn player_len(&self) -> usize;

    fn current_player(&self) -> P;

    fn available_actions(&self) -> Vec<A>;

    fn do_action(&mut self, action: A);

    fn apply_action(mut self, action: A) -> Self {
        self.do_action(action);
        self
    }

    // if the state is on cycle, use partial reward instead of game over reward
    fn partial_rewards(&self) -> Vec<f64>;

    // if the state is game over, return the reward of each players by id.
    fn game_over(&self) -> Option<Vec<f64>>;
}

struct StateNode<A: Action> {
    available_actions: Vec<A>,
    total_reward: Vec<AtomicF64>,
    total_visit: AtomicU64,
}

/// The node info for public
///
/// This can generated by `self.node_info_from`
#[derive(Debug)]
pub struct StateNodeInfo {
    pub total_reward: Vec<f64>,
    pub total_visit: u64,
}

#[derive(Serialize, Deserialize)]
struct MCTSInfo {
    total_node: AtomicU64,
    total_rollout: AtomicU64,
    partial_rewards: AtomicU64,
    ignored_max_depth_rollout: AtomicU64,
    ignored_try_cycle_by_uct: AtomicU64,
    ignored_cycle_rollout: AtomicU64,
}

#[derive(PartialEq)]
pub enum CyclePolicy {
    Allow,
    Ignore,
    PartialReward,
}

pub struct MCTSOption {
    max_depth: usize,
    cycle_policy: CyclePolicy,
}

impl MCTSOption {
    pub fn new(max_depth: usize, cycle_policy: CyclePolicy) -> Self {
        Self {
            max_depth,
            cycle_policy,
        }
    }
}

impl fmt::Display for MCTSInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MCTSInfo")
            .field(
                "total_node",
                &thousands_separate(self.total_node.load(Ordering::Relaxed)),
            )
            .field(
                "total_rollout",
                &thousands_separate(self.total_rollout.load(Ordering::Relaxed)),
            )
            .field(
                "partial_rewards",
                &thousands_separate(self.partial_rewards.load(Ordering::Relaxed)),
            )
            .field(
                "ignored_max_depth_rollout",
                &thousands_separate(self.ignored_max_depth_rollout.load(Ordering::Relaxed)),
            )
            .field(
                "ignored_cycle_rollout",
                &thousands_separate(self.ignored_try_cycle_by_uct.load(Ordering::Relaxed)),
            )
            .field(
                "ignored_try_cycle_by_uct",
                &thousands_separate(self.ignored_cycle_rollout.load(Ordering::Relaxed)),
            )
            .finish()
    }
}

pub struct MCTS<P: Player, A: Action, S: State<P, A>> {
    state_map: DashMap<S, StateNode<A>>,
    info: MCTSInfo,
    option: MCTSOption,
    _marker: PhantomData<(P, A)>,
}

// https://stackoverflow.com/questions/26998485/rust-print-format-number-with-thousand-separator
fn thousands_separate(x: u64) -> String {
    let s = format!("{}", x);
    let bytes: Vec<_> = s.bytes().rev().collect();
    let chunks: Vec<_> = bytes
        .chunks(3)
        .map(|chunk| String::from_utf8(chunk.to_vec()).unwrap())
        .collect();
    let result: Vec<_> = chunks.join(",").bytes().rev().collect();
    String::from_utf8(result).unwrap()
}
